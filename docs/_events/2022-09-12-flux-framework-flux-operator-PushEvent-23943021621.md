---
event_type: PushEvent
avatar: "https://avatars.githubusercontent.com/u/814322?"
user: vsoch
date: 2022-09-12
repo_name: flux-framework/flux-operator
html_url: https://github.com/flux-framework/flux-operator/commit/6f54a399fd230f30e4c29083870a585a7472d03e
repo_url: https://github.com/flux-framework/flux-operator
---

<a href='https://github.com/vsoch' target='_blank'>vsoch</a> pushed to <a href='https://github.com/flux-framework/flux-operator' target='_blank'>flux-framework/flux-operator</a>

<small>adding update to /etc/hosts (#16)

* summary of changes

- We have a strategy for /etc/hosts
- _One_ curve cert is generated by the main pod and shared between them via a persistent volume
  - If we use a cloud K8s we might be able to use persistent volume claim and should be able to switch between the two
- A flux user is created in each container, assumes a creation command and this might not be the case depending on the base OS (we might have different templates for different OS and ask the user as part of the MiniCluster config)
- Events are moved into events.go and can be deleted if we don't need them. If this is the case we can also move the Client from an attribute on the Reconciler to be inherited (e.g., r.Get vs r.Client.Get)
- My first attempt at a podExec function are moved into extra.go - if we need/want this we can debug further, otherwise it's not used and safe to delete.
- Having the wait / startup script generate the certificate, and only given the main pod hostname, made the initContainers redundant (and I removed them).
- Configs/templates are moved into templates.go so they are easier to find.
- GetHostfileConfig is not GetConfigMap (and more generalized)
- listed pods are now sorted by name so they are returned consistently
- A ConfigMap volume at `/flux_operator` is where we are writing the entrypoint script (wait.sh) the start script, and the update_hosts.sh script.

* adding update to/etc/hosts

this is a bit of a hack that adds a script wrapper to the pod start,
and the wrapper waits until it sees a file populated with ip addresses
(or more specifically, echos to update /etc/hosts.). I think we can
do this because when the pod is re-created, the ip address does not
change! And what is happening while it is waiting is that a config
map is updated with the (now known) ip addresses. This seems to
allow the /etc/hosts to be correctly populated (determined by ping
working) and I think next I need to debug why the broker still
thinks it is waiting.

* clean up unused functions

* separating main node (to generate cert and start) from workers

my flux still is not connecting "Unable to connect to Flux"
so I need to debug this. But I (?)think it is more correct that
only one of the nodes is running the start command and generating
the certificate. Technically if this node knows that it can use
the other ones we should not need to run it multiple times.

* ensure we use a persistent volume for curve

with the emptydir strategy each node had its own mount. If
we use a persistent volume claim each node has access to
the same certificate, and we do not need to worry about race
because it is specifically written by just one hostname

* good state - we have flux almost running, quorum delayed

Signed-off-by: vsoch <vsoch@users.noreply.github.com></small>

<a href='https://github.com/flux-framework/flux-operator/commit/6f54a399fd230f30e4c29083870a585a7472d03e' target='_blank'>View Commit</a>